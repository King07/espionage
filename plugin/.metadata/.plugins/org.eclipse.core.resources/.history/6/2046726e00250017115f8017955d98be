package edu.cwi.espionage.model;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.IterableMap;
import org.apache.commons.collections.MapIterator;

import edu.cwi.espionage.util.Date;

public class Cases implements IterableMap {
	Map<String,ProcessCase> processCases;

	public Cases() {
		processCases = new HashMap<String,ProcessCase>();
	}
	
	public boolean exist(String caseId){
		return processCases.containsKey(caseId);
	}
	
	public void add(ProcessCase processCase){
		processCases.put(processCase.getCaseId(), processCase);
	}
	
	public ProcessCase get(String caseId){
		return processCases.get(caseId);
	}
	public void printCases(){
		Iterator<Entry<String, ProcessCase>> it = processCases.entrySet().iterator();
	    while (it.hasNext()) {
	        Map.Entry<String, ProcessCase> pair = (Map.Entry<String, ProcessCase>)it.next();
	        System.out.println(pair.getKey());
	        System.out.println("RAW === " + pair.getValue().getTotalTime());
	        System.out.println("FORMATED === " + Date.getFormatedDiff(pair.getValue().getTotalTime()));
	        it.remove(); // avoids a ConcurrentModificationException
	    }
	}
	@Override
	public String toString() {
		return processCases.toString();
	}

	@Override
	public int size() {
		return processCases.size();
	}

	@Override
	public boolean isEmpty() {
		return processCases.isEmpty();
	}

	@Override
	public boolean containsKey(Object key) {
		return processCases.containsKey(key);
	}

	@Override
	public boolean containsValue(Object value) {
		return processCases.containsValue(value);
	}

	@Override
	public Object get(Object key) {
		return processCases.get(key);
	}

	@Override
	public Object put(Object key, Object value) {
		return processCases.put((String) key, (ProcessCase) value);
	}

	@Override
	public Object remove(Object key) {
		return processCases.remove(key);
	}

	public void putAll(Map<String, ProcessCase> m) {
		processCases.putAll(m);
		
	}

	@Override
	public void clear() {
		processCases.clear();
		
	}

	@Override
	public Set keySet() {
		return processCases.keySet();
	}

	@Override
	public Collection values() {
		return processCases.values();
	}

	@Override
	public Set entrySet() {
		return processCases.entrySet();
	}

	@Override
	public MapIterator mapIterator() {
		return ((IterableMap) processCases).mapIterator();
	}
	

}
