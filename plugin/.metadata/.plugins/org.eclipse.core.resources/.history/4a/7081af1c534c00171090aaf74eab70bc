package edu.cwi.espionage.model;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import edu.cwi.espionage.util.DateManipulator;
import edu.cwi.espionage.util.IdleTimeTable;
import edu.cwi.espionage.util.Utils;

public class ProcessCase implements Comparable<ProcessCase>, Cloneable{
	private static final long MINIMUM_IDLE_TIME = 600; //10 minutes as default.
	private String caseId;
	private List<Event> events;
	private long startTime;
	private long idleTime;
	private Event lastEvent;
	private IdleTimeTable idleTimeTable;
	
	public ProcessCase(String caseId) {
		this.events = new ArrayList<Event>();
		this.setCaseId(caseId);
		this.setIdleTimeTable(new IdleTimeTable());
	}

	public String getCaseId() {
		return caseId;
	}

	public void setCaseId(String caseId) {
		this.caseId = caseId;
	}

	public List<Event> getEvents() {
		return events;
	}

	public void setEvents(List<Event> events) {
		this.events = events;
	}
	
	public void addEvents(Event event) {
		this.events.add(event);
	}

	public long getIdleTime() {
		return idleTime;
	}

	public void setIdleTime(long idleTime) {
		this.idleTime = idleTime;
	}

	public long getDateTotalTime() {
		Long processTime = new Long(0);
		for (Event event : events) {
			processTime += event.getElapstime();
		}
		System.out.println("Global Time = "+processTime );
		System.out.println("Idle Time = "+getIdleTime() );
		return DateManipulator.diff(processTime,getIdleTime()) * 1000;
	}
	
	public long getTotalIdleTime() {
		return getIdleTimeTable().total();
	}
	
	public long getTotalTime(Date upper, Date lower) {
		long total = new Long(0);
		for (ProcessCase p : getByDate(upper,lower)) {
			total +=p.getDateTotalTime();
			
		}
		return total;
	}
	public long getTotalTime() {
		
		return getTotalTime(null,null);
	}
	
	public List<ProcessCase> getByDate(Date upper, Date lower) {
		List<ProcessCase> pc = new ArrayList<>();
		List<Event> eventsTemp = new ArrayList<>(events);
		while (!eventsTemp.isEmpty()) {
			Event topEvent = eventsTemp.get(0);
			ProcessCase pcTemp = new ProcessCase(getCaseId());
			for (Event e : events) {
			
				if(topEvent.compareTo(e) == 0){
					if(pcTemp.getEvents().isEmpty()){
						pcTemp.setStartTime(e.getTimestamp().getTime()/1000);
					}
					else{
						 pcTemp = calculateIdleInactiveTime(pcTemp, e);
						
					}
					
					if(isDateRangeNull(upper, lower) || isDateBetwwenRange(upper, lower, e.getTimestamp())){
						pcTemp.addEvents(e);
						pcTemp.setLastEvent(e);
						
					}
					eventsTemp.remove(e);
					
				}
			}
			if(pcTemp.getLastEvent() != null){
				String formatedDate = DateManipulator.getFormatedDate(pcTemp.getLastEvent().getTimestamp(), "dd/MM/yyyy");
				Long lookupIdleTime = new Long(0);
				if(isDateRangeNull(upper, lower)){
					
					 lookupIdleTime = this.getIdleTimeTable().total(formatedDate, 1, 24);
					 System.out.println("if getIdleTimeTable() = "+getIdleTimeTable());
				}else{
					System.out.println("else getIdleTimeTable() = "+getIdleTimeTable());
					 lookupIdleTime = this.getIdleTimeTable().total(formatedDate, DateManipulator.getHourFromDate(lower), DateManipulator.getHourFromDate(upper));
				}
				
				pcTemp.setIdleTime(lookupIdleTime);
				pc.add(pcTemp);
			}
		}
		return pc;
	}

	private boolean isDateRangeNull(Date upper, Date lower) {
		return upper == null || lower == null;
	}
	
	private boolean isDateBetwwenRange(Date upper, Date lower, Date toCheck) {
		boolean inBetween = toCheck.getTime() >= lower.getTime() && toCheck.getTime() <= upper.getTime();
		if(inBetween){
			return true;
		}
		return false;
	}

	private ProcessCase calculateIdleInactiveTime(ProcessCase pcTemp, Event e) {
		Event event2 = pcTemp.getEvents().get(pcTemp.getEvents().size()-1);
		if (IsInactive(event2, e)) {
			long idleTime = DateManipulator.getSecondsFromDiff(getInactiveTime(e, event2));
			
			String formatedDate = DateManipulator.getFormatedDate(e.getTimestamp(), "dd/MM/yyyy");
			Integer hourFromDate = DateManipulator.getHourFromDate(e.getTimestamp());
			System.out.println("IsInactive(event2, e) "+idleTime+"  <=> hourFromDate "+hourFromDate);
			pcTemp.getIdleTimeTable().add(formatedDate,hourFromDate,idleTime);
		}
		return pcTemp;
	}
	
	/**
	 * To calculate inactive time:
	 * CONTEXT: The fluorite log all developers events. 
	 * METHOD : Visualizing Developer Interactions by  Roberto Minelli, Andrea Mocci, Michele Lanza and Lorenzo Baracchi
	 * 			idle time = event2 - event1 => if idle time is more than “minimum  idle  time (10 minutes)”, Then it suggest
	 * 			that the user is inactive.
	 * {@link http://conferences.computer.org/vissoft/2014/papers/6150a147.pdf } 
	 * @param Event e1
	 * @param Event e2
	 * 
	 * @return
	 */
	private long getInactiveTime(Event e1, Event e2){
		Event firstEvent = e1;
		Event secondEvent = e2;
		if(e1.getTimestamp().after(e2.getTimestamp())){
			firstEvent = e2;
			secondEvent = e1;
		}
//		System.out.println("firstEvent = "+firstEvent);
//		System.out.println("secondEvent = "+secondEvent);
		
		return Math.abs(secondEvent.getTimestamp().getTime() - firstEvent.getTimestamp().getTime());
	}
	
	private boolean IsInactive(Event e1, Event e2){
		Event firstEvent = e1;
		Event secondEvent = e2;
		if(e1.getTimestamp().after(e2.getTimestamp())){
			firstEvent = e2;
			secondEvent = e1;
		}
		
		boolean isInactive = false;
		long inactiveTime = getInactiveTime(firstEvent,secondEvent);
		long inactiveTimeSeconds = inactiveTime/1000;
		if(inactiveTimeSeconds > MINIMUM_IDLE_TIME && inactiveTimeSeconds == secondEvent.getElapstime() ){
			System.out.println("MINIMUM_IDLE_TIME = "+MINIMUM_IDLE_TIME);
			System.out.println("inactiveTime = "+inactiveTimeSeconds+" <==> "+"secondEvent.getElapstime() = "+secondEvent.getElapstime());
			
			isInactive = true;
		}
		return isInactive;
	}
	
	@Override
	public String toString() {
		return Utils.getClassName(getCaseId(), "/");
	}

	public Event getLastEvent() {
		return lastEvent;
	}

	public void setLastEvent(Event e) {
		this.lastEvent = e;
	}

	public long getStartTime() {
		return startTime;
	}

	public void setStartTime(long startTime) {
		this.startTime = startTime;
	}

	public IdleTimeTable getIdleTimeTable() {
		return idleTimeTable;
	}

	public void setIdleTimeTable(IdleTimeTable idleTimeTable) {
		this.idleTimeTable = idleTimeTable;
	}

	@Override
	public int compareTo(ProcessCase p) {
		long ans = p.getTotalTime() - this.getTotalTime() ;
		return new Long(ans).intValue();
	}
	
	public Object clone()throws CloneNotSupportedException{  
		return super.clone();  
	}
	
	
}
